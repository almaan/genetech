---
title: "Lab3 - Single Cell RNAseq"
author: "Original : Joseph Bergenstr√•hle - Edit : Ludvig Larsson, Alma Andersson, Sailendra Pradhananga "
date: "06 Dec 19"
output:
  tufte::tufte_html: default 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

____
## Lab3 - Single cell RNA seq (scRNA-seq)
____

Today, it's possible to get genomic information even from single cells. (You
should have heard about single cell RNA-seq in the lectures!). Traditionally,
many of the methods used to analyze RNA-seq data were developed with standard
"bulk" RNA-seq in mind. However, some of the underlying assumptions that are
used for "bulk" RNA-seq methods are not appropriate for analyzing scRNA-seq
data.

The most obvious advantages with the new single cell technologies is the 
fact that we're no longer measuring an average across a larger population and
also the massive throughput (i.e. the number of cells that can be analyzed). 
This opens up for a number of possibilities to study tissues and organs at an
unpresedented resolution. Today, reseearchers can collect even millions of 
cells from a tissue to create atlases, a bit like a google earth for cell types. 

____
## 1) Introduction
____

Short primer: what is scRNA-seq?

* Measures the expression levels for each gene across a population of cells.
* Adresses biological questions in which cell-specific changes in
  transcriptome are important, e.g. cell type identification, heterogeneity of
  cell responses, stochasticity of gene expression, inference of gene regulatory
  networks across the cells.
* Currently there are several different protocols in use, e.g. SMART-seq2,
  CELL-seq and Drop-seq.
*  There are also commercial platforms available, including the Fluidigm C1, 10X
   Genomics Chromium etc.
*  Several computational analysis methods from bulk RNA-seq can be used.
*  In most cases computational analysis requires adaptation of the existing
   methods for bulk RNA-seq analyses or development of new ones.
   

This is a general pipeline for an scRNA-seq analysis workflow

![](flowchart_rnaSeq.png)

____
## 2) Construct the expression matrix
____

Ok, let's start by looking at our expression matrix. Note that in the workflow
schematic above, we will skip the Read QC, Alignment, Mapping QC, and Cell QC
steps. Let's assume this (boring ;-)) stuff has already been done.

Here we have provided you with an already quality-controlled dataset, consisting
of pluripotent stem cells. Load the data!

```{r, eval=FALSE}
data <- read.table("data/tung.tsv")

```

The object called `data` is an object of class `data.frame`. A `data.frame` 
object is usually used to store any kind of tabular data in R. It's always a 
good idea to get familiar with the data, so you can for example check the class,  
dimensions and the content of the `data.frame`. This `data.frame` contains 
single-cell data where the genes (features) are in the rows and cells are in columns.

```{r, eval=FALSE}
# Check class
class(data)

# Check dimensions
dim(data)

# Print top left corner
data[1:5, 1:5]

```

### The Seurat R package 

We will use the "Seurat" R package, developed by the Satija Lab
https://satijalab.org/ at NYU. Seurat has become one of the most popular 
tools for single cell analysis in R and is constantly updated with new features. 
There are many tutorials available on their website to get started with various 
types of analyses which is also a reason why it has become so popular among 
researchers.

A core feature of Seurat is the `Seurat` object. Without going into too much detail,
this is an object designed to store all relevant input data as well as analysis results.
This includes raw expression data, normalized data, dimensionality reduction outputs and
much more. The `Seurat` object is an S4 class object and has a bunch of methods 
associated with it. The methods available from the `Seurat` package are just like functions 
in R, but have been specifically designed to work on `Seurat` objects. Many of them are 
just there for convenience to make it easier to extract and put in data into the `Seurat` object.
We will familiarize ourselves with some of these functions, but it's always a good idea to 
explore the package documentation to make life easier.

If you have installed the Seurat R package, the only thing you need to create a 
`Seurat` object is an expression matrix with cells in columns and genes in rows. 
Once this object has been created, Seurat provides all the tools necessary to run 
the steps described in the flowchart above using a set of predefined functions. 

Load the Seurat R package (install via BiocManager::install() if not already installed)

```{r, eval=FALSE}
#BiocManager::install('Seurat')
library(Seurat)

```

Before we create our `Seurat` object, it can be useful to include some meta data as well. 
Meta data is typically a table with additional information about our cells, e.g. if they were processed
in separate batches or obtained from different individuals. 

```{r, eval=FALSE}
metadata <- read.table(file = "data/tung_metadata.tsv", stringsAsFactors = FALSE)
head(metadata)

# Check that rownames of meta data matches colnames of gene expression data
check <- all(rownames(metadata) == colnames(data))

sprintf("gene expression colnames matches meta data rownames: %s", check)

```

Note that the rownames of the meta data table matches the column names of the expression
matrix. This is important to make sure that the meta data is associated with the correct cells.

Let's create a `Seurat` object with our expression matrix and meta data table.

```{r, eval=FALSE}
se <- CreateSeuratObject(counts = data, meta.data = metadata)
```

To access the meta data from your new Seurat object, you can use double brackets `[[]]`.

```{r, eval=FALSE}
# Check the meta data
head(se[[]])

```

Notice that you have some additional columns in your meta data whcih have been added 
automatically when you created your Seurat object. For example; `nCount_RNA` which is the number 
of unique molecules detected per cell and `nFeature_RNA` which is the number of unique genes
detected per cell. 

You can access any column from you Seurat object using the `$` symbol, just like you would
with a `data.frame` object. Below is an example of how to extract the "replicate" column
and then summarizing how many cells from each replicate that we have.

```{r, eval=FALSE}
table(se$replicate)
```

*Q1:* How many genes do we have? How many cells?

```{r, eval=FALSE, echo=TRUE}
# Write your code / answer here
# Replace NA with the correct values

number.of.genes <- NA
number.of.cells <- NA

cat(sprintf("Number of genes: %s\nNumber of cells: %s", number.of.genes, number.of.cells))
  
```

Single-cell data typically contains _a lot_ of "samples" (cells). Due to the
size of the count matrix and the high frequency of 0 values, `Seurat` stores the
data in a "sparse matrix format" to save memory. 

You can access the raw data using the `GetAssayData` method and specify that 
you want to collect the raw expression matrix by typing `slot = "counts"`. Note 
that this matrix is the same as the `data` matrix that we used to create our `Seurat` object. 
It's important to know how to extract data from the Seurat object as well, for example when 
you need to apply a method which is not available from the `Seurat` R package. 

```{r, eval=FALSE}
sparse.exprMat <- GetAssayData(se, slot = "counts")
```

Now we have the raw expression matrix in a sparse format saved to a variable called 
`sparse.exprMat`. Let's have a look at the top left corner of the matrix (first 5 genes
and first 5 cells). 

```{r}
# Check class of object 
class(sparse.exprMat)

# Extract top left corner
sparse.exprMat[1:5, 1:5]
```

Note that class of the matrix is called "dgCMatrix" which is a type of sparse matrix format. 
This format is only useful when the data contains a lot of 0 values, which is the case for 
scRNA-seq data. The 0 values aren't actually stored in memory which saved a lot of space.

Column names such as "NA19098.r1.A01" or "NA19098.r1.A02" represent unique cell identifiers,
whereas the gene names are given here as gene symbols (HGNC nomenclature).

Sometimes, it's easier to work with a "normal" matrix and if you want to you can simply convert
the sparse matrix into a normal matrix using the `as.matrix` function:

```{r, eval=FALSE}
exprMat <- as.matrix(sparse.exprMat)

# Check class of object 
class(exprMat)

# Extract top left corner
exprMat[1:5, 1:5]
```

____
## 3) Quality Control (QC)
____

Now, some cells in your expression matrix might be too "bad" to include in your analysis. 
Cells with very few detected RNA molecules are sometimes too sparse to extract meaningful 
information from and if these cells are kept they could have a negative impact on our
analysis. It's usually a good idea to explore the data visually to make sense of various
quality aspects and then apply some filters to decide what cells to keep.

### Number of unique genes per cell

To visualize the distribution of number of unique genes per cell, we can use a histogram. 
Take a look at the histogram of some synthetic data representing unique genes detected per cell:

```{r, eval=FALSE, echo=TRUE}
# Plot histogram
nGenes <- rnorm(n = 1e4, mean = 4e3, sd = 500)
hist(nGenes, breaks = 50)
```

We can add additional things to our histogram, e.g. a vertical line highlighting a cut-off point.
Here we'll highlight the `mean` values, and the 1st and 2nd standard deviations (`sd`) from the `mean`.

```{r, eval=FALSE, echo=TRUE}
# plot histogram
hist(nGenes, breaks = 50)

# Add vertical lines
# col = "color", lty = "linetype", lwd = "line width"
abline(v = mean(nGenes), col = "black", lty = "longdash", lwd = 2)
# 1st standard deviation
abline(v = mean(nGenes) - sd(nGenes), col = "darkred", lty = "longdash", lwd = 2)
abline(v = mean(nGenes) + sd(nGenes), col = "darkred", lty = "longdash", lwd = 2)
# 2nd standard deviation
abline(v = mean(nGenes) - 2*sd(nGenes), col = "red", lty = "longdash", lwd = 2)
abline(v = mean(nGenes) + 2*sd(nGenes), col = "red", lty = "longdash", lwd = 2)
```

*Q2:* Make a histogram of the total number of RNA molecules detected per cell 
(nFeature_RNA) using the `Seurat` object. Then, highlight the 2nd standard deviation
from the mean as vertical lines.

Hint: you can access meta data using the `$` symbol. 

```{r, eval=FALSE, echo=TRUE}
# Write your code / answer here
```

Sometimes it can be useful set filtering thresholds using statistical measures such as
mean +/- standard deviation, but in real data you typically set a threshold based on visual 
inspection. Histograms are useful, but the `Seurat` package contains other neat methods to 
plot quality measurements from your data. The `VlnPlot` method makes it easy to explore 
quality metrics and also makes it very easy to examine batches separately. Each dot in the 
violin plot represents a cell and the colored shape behind the dots reflects the density 
distrubution (much like a tilted histogram). Here you can for example see that the cells 
with the lowest number of unique genes are found in replicate 3. 

```{r, eval=FALSE, echo=TRUE}
VlnPlot(se, features = "nFeature_RNA", group.by = "replicate")
```

Based on this plot, we could for example decide to filter out cells with fewer than 5000 unique 
genes. The `VlnPlot` method uses the `ggplot2` R package to draw the plots, so if we want to 
add lines we cannot use the `abline` function like we did before. Instead we'll use a function
called `geom_hline`. 

```{r, eval=FALSE, echo=TRUE}
VlnPlot(se, features = "nFeature_RNA", group.by = "replicate") +
  geom_hline(aes(yintercept = 5000, color = "threshold"), linetype = "longdash") +
  labs(color = "") + # Remove title from color legend
  scale_color_manual(values = c("threshold" = "black")) # Change color of line to "black"
```

*Q3:* Create a new violin plot using `VlnPlot`, but this time include two quality features; 
number of unique genes per cell and number of molecules per cell.

Hint: the features argument of `VlnPlot` can take a character vector with more than 1 feature.

```{r, eval=FALSE, echo=TRUE}
# Write your code / answer here
```

_____
## 4) Filter
_____

Filtering a "Seurat" object from low quality cells can be done by first identifying 
the cell names that you want to keep and use these names to subset the object.

Let's filter out cells that have less than 1 million unique molecules or less than 7 thousand 
unique genes. Below are a few lines of code to extract cell names for cells meeting 
these two criteria and these cell names are stored in the `keep.cells` character vector.

*Q4:* Use the `keep.cells` character vector to subset the "Seurat" object and complete the
code chunk below. Save the new "Seurat" object into a variable called `se.subset`.

Hint: You can for example use the `subset`. Type ?subset.Seurat in the R console to 
open up a documentation window for the `subset` function.

```{r, eval=FALSE, echo=TRUE}

# Select cell names with at least 1 million unique molecules
set1 <- se$nCount_RNA >= 1e6
# Select cell names with at least 7000 unique genes
set2 <- se$nFeature_RNA >= 7000

# Select cells where both criteria above are met (set1 AND set2 has to be TRUE)
keep.cells <- colnames(se)[set1 & set2]
head(keep.cells)

# Now use these cell names to subset the "Seurat" object

# Write your code / answer here

```

You will often find that some genes are lowly expressed across your dataset. It can be a 
good idea to filter out such genes as these are not always informative. We can compute the 
overall expression per gene by summing up the count for each row:

```{r, eval=FALSE}
# First get the expression matrix
sparse.exprMat <- GetAssayData(se, slot = "counts")

# Convert it into a regular matrix
exprMat <- as.matrix(exprMat)

# Calculate row sums
gene.counts <- rowSums(exprMat)

# Check the results 
head(gene.counts)
```

*Q5:* Compute a new vector (call it `keep.genes`) containing the genes with a total
expression lower than 500 across the whole dataset. The `keep.genes` character vector 
should consist of genes symbols.

Hint: You can use the vector called `gene.counts` to determine what genes to keep. 
Check the example above where we filtered out cells.

```{r, eval=FALSE, echo=TRUE}
# Write your code / answer here
```

Now that we have this vector we can subset the "Seurat" object we did previously,
but this time we'll apply the filter to the genes instead.

```{r, eval=FALSE, echo=TRUE}
se.subset <- subset(se.subset, features = keep.genes)
```

Now that we have filtered our object (`se.subset`), we should have fewer cells
and fewer genes. 

*Q6:* How many cells do we have now? How many genes?

```{r, eval=FALSE, echo=TRUE}
# Write your code / answer here
```

_____
## 5) Normalization
_____

There are some specific challenges associated with single cell data. In particular, 
the major challange is that the data is much sparser compared to bulk RNA-seq data. 
A result of this is that the number of genes detected in a single cell is typically 
only a fraction of the number of genes expressed across the genome. In other words, 
a lot of genes have 0 expression in a cell.

The missing genes are referred to as **gene "dropouts"** and these make it challenging to 
compare expression levels across cells. Dropouts are less common in bulk sequencing data 
because you measure expression levels from a large number of cells at the same time, thus 
increasing the change of measuring any one gene.

The total amount of RNA molecules that are measured in a cell (referred to as "library size") 
depends on a number of technical and biological features. For example, larger cells typically 
contain more RNA molceules while cells with a lot of RNAse enzyme contain less RNA as a result 
of degradation. These are examples of sources of variability which we are not interested in 
and are commonly referred to as "confounding factors". 

To make the expression levels comparable across cells, we can adress confounding factors
by applying a normalization method. A good normalization strategy can be used to transform a
raw expression matrix into a new matrix where expression levels are comparable across cells 
in a meaningful way. You can find a number of normalization strategies and more in depth theory
[here](https://scrnaseq-course.cog.sanger.ac.uk/website/cleaning-the-expression-matrix.html#normalization-theory).

In this course, we will use a method called variance stabilizing transformation, 
[VST](https://www.biorxiv.org/content/10.1101/576827v2) method which is provided 
by the `SCTransform` function from the `Seurat` package:

```{r, eval=FALSE}
se <- SCTransform(se)
```

Now, you will have a new "assay" stored in the `Seurat` object called "SCT",
which contains the normalized data. This assay will automatically become 
the "active" assay for subsequent analyses. The "active" assay contains 
data that it will be used as input to any method that you apply to your 
`Seurat` object. In practice, this means that whatever method you apply 
to you expression data from now will be applied to the normalized data. 

If you type `DefaultAssay(se)`, you should get "SCT".

```{r}
DefaultAssay(se)
```

If you just paste the object in your console and hit ENTER, you will get some basic information 
about the dataset such as what assays that are present and which one is active. 
You could have any number of assays available and it's important to know what assay
you're working on. Here you can also see that the "active" assay is "SCT" but you also
have another assay called "RNA" which contains the raw data. If you want to switch assays
you can use the `DefaultAssay <- ` method instead, like this:

`DefaultAssay(se) <- "RNA"`

Check the output of pasting se + ENTER:

```{r}
se
```

_____
## 6) Dimensionality reduction
_____

A single-cell dataset is composed of several cell types which are all characterized by the 
expression of specific sets of genes. If we were to zoom in on a specific cell type, it is 
reasonable to expect that there exists some set a co-expressed genes which defines this cell type. 
For example, you might find that a cell type express genes related to neuronal activity, immune 
respones or oxygen transport. 

In reality, an expression matrix represent many complex interactions between different genes and these 
interactions can vary across different cell types and cell states. But there are typically some very clear
patterns in the data and what we want to do is to make sense of these patterns. 
One major benefit with scRNA-seq data is that we can fish out different patterns using machine learning 
methods. Dimensionality reduction methods represent a family of machine learning methods which are 
particularly suitable for this task.

As the name implies, a dimensionality reduction method can be used to reduce a high dimensional dataset into a 
representation with fewer dimensions. These new dimensions can pick up sources of variability in the dataset, 
such as signalling pathways, immune functions, metabolic activity, apoptotic activity and much more. The most 
useful patterns are often the ones that represent some biological variability, but you can also find patterns 
that represent technical variability. An example of this could be if you have doublet cells in your data. We are 
only interested in analyzing individual cells, but sometimes two or more "connected" cells slip through the 
experimental procedure because of technical limitations. We can adress most of the technical variability using 
normalization and filtering procedures, but you should always keep an eye things like this.

The interpretation of dimensionality reduction vectors can be confusing, so it can be helpful to think of them as 
patterns representing some biological or technical variability.

For scRNA-seq data, dimensionality reduction methods are also crucial to visualize the data! 

First, let's have a look at the most widely used dimensionality reduction method called 
Pincipal Component Analysis (PCA). This method can be applied to our Seurat object 
using the `RunPCA` function.

Let's first compute a PCA representation of our data:

```{r, eval=FALSE}
se <- RunPCA(se)
```

We can then plot the transformed data by using the function `DimPlot()` and specify the reduction that we want to use:

```{r, eval=FALSE}
DimPlot(se, reduction = "pca", dims = c(1, 2))
```

Here we have plotted the first two PCA vectors (1 and 2) by setting `dims = c(1, 2)` 
and you can only visualize two at the time. PCA vectors are centered at 0 so you will always 
get both positive and negative values on the axes. You can already see that the cells 
form two groups in the plot.

We can also color the cells using information from our meta data table. Let's color
the cells based on replicate:

```{r, fig.width=7, fig.height=6}
DimPlot(se, reduction = "pca", dims = c(1, 2), group.by = "replicate")
```

Exploring these types of plots can be useful to find out if variablity in your data can somehow be 
attributed to previous knowledge about your data. Looking at PC_2 you can see that the population 
of cells from replicate "r1" differ from the other two replicates. The effect is not super clear, 
but we can for example use the `VlnPlot` function as we did before:

```{r, eval=TRUE}
VlnPlot(se, features = "PC_2", group.by = "replicate")
```

Here you can clearly see that r1 stands out. We actually know here that these are technical replicates, 
meaning that the cells have been sampled from the same poulation, so we can draw the conclusion that 
this effect is technical and should be removed. This type of technical effect found between groups 
processed independently is commonly referred to as a "batch effect".

Luckily, the `SCTransform` normalization method allows us to model and account for suc batch efffects.
What we have to do is to specify a batch variable so that the `SCTransform` function knows 
how the cells are partitioned into different batches. We can do this using the `var.to.regress` 
argument.

```{r}
se <- SCTransform(se, vars.to.regress = "replicate")
se <- RunPCA(se)
```

Now we should see that the separation of replicates along PC_2 has been reduced.

```{r}
VlnPlot(se, features = "PC_2", group.by = "replicate")
```

*Q7:* Let's pretend that the individual represents a batch effect that we want to remove 
from our data. Re-run the normalization with SCTransform and include both "replicate" and
"individual" as variable to regress out (`vars.to.regress`).

```{r, eval=FALSE}
# Write your code / answer here

```

In most larger studies on single-cell data, technical batch effects can be very hard to isolate and 
account for. The batch correction method used here works well for small effects, but 
more sophisticated methods are often required. But above all, it is crucial to think 
carefully about the experimental design even before you start analyzing your cells in 
the wetlab, so that you can actually isolate batch effects at all. 

Take the Tung dataset that we just used as an example. If the individuals were 
processed in three different batches, it would very difficult to distinguish technical 
variability across batches from biological variability across individuals!

_____
## PBMC data
_____

For the rest of this lab, we'll use a different dataset with peripheral
blood mononuclear cells (PBMCs). PBMCs are extracted from blood samples 
and contain mainly immune cells such as lymphocytes and monocytes. 

When you run `pbmc <- readRDS("data/pbmc")` you will get a `Seurat` object 
that has already been normalized. 

```{r}
pbmc <- readRDS("data/pbmc")
```

Let's try another dimensionality reduction method called UMAP. This method
is commonly used to "embed" the cells into a 2D map that can be very useful
for visualization purposes. 

```{r, eval=FALSE, warning=FALSE, message=FALSE}
pbmc <- RunUMAP(pbmc, dims = 1:30)
DimPlot(pbmc, reduction = "umap")
```

Here you can already see some interesting structures in the data; some bigger blobs, some
smaller blobs, some are isolated and some are connected. In a UMAP plot, cells with similar 
gene expression are put close to each other so you get something to point at when describing
cell types or cell states.

We shouldn't draw too many conclusions from the map itself, but you'll hopefully see that the map actually
represents a lot of interesting biology. Now the next question is, where do we draw the lines to separate 
these blobs into meaningful groups?

_____
## 7) Clustering 
_____

Clustering of scRNA-seq data refers to methods used to group samples (cells) based 
on gene expression similarity (https://www.nature.com/articles/nmeth.4299). The methods 
are typically unsupervised or semi-supervised, meaning that we can define group structures 
in the data with little or no prior knowledge about the data beforehand. It's important to 
understand that clustering methods will define structures in your data, but they don't tell
you if the structures are truly representative of cell types or not. Cells can for example 
be differentiating, proliferating or adapting to their surroundings (microenvironment), 
therefore producing a spectrum of cell states without clear cut border. We often have to 
compromise and sometimes even group the cells in different levels of detail. 

For example, consider a rich scRNA-seq dataset with tens of thousands of cells collected from 
an inflamed tissue sample. Here you have identified a_ memory B-cell_ in the dataset. In a broader 
context when looking at whole tissue sample, the _memory B-cell_ would belong to _immune cells_ 
(together with _T-cells_, _macrophages_, _dendritic cells_, _granulocytes_ etc.). If you zoom in
on the _immune cells_ you can further subdivide them into _lymphocytes_ and _myeloids_.
Add another level of detail and you can divide the _lymphocytes_ into _B-cells_, _T-cells_ and
_natural killer cells_. Aaaaaand finally you might end up splitting the _B-cells_ into 
_naive B-cells_, _memory B-cells_ and _plasma cells_. But it doesn't even have to stop here, 
These _memory B-cells_ might exist in different sub types or states depending on where they are
and how they developed. This may seem a bit messy, but the fact that you can create these
lineages of cells is to a large extent what makes scRNA-seq methods so useful!!!


Anyways, in standard scRNA-seq analysis workflow, you are typically interested in defining 
cell types so let's see how that works on our smaller dataset of about 3000 cells. 
What people usually do is to cluster the cells and then define (annotate) the clusters as 
different cell types based on their specific expression of "marker genes". Here, marker 
genes can be thought of as genes known to be specifically expressed by a specific cell type, 
e.g. CD19 is known to be expressed only by B-cells. However, you should know that most of the 
time you can tweak parameters to obtain different clusters and it can be very difficult to 
find the optimal parameter settings. 

Let's try clustering our data using the default method provided by Seurat's 
`FindNeighbors()` and `FindClusters()` functions. The parameter called `resolution` can
be tweaked to obtain a different number of clusters. Lowering this value will result in fewer clusters
and increasing this value will result in more clusters. Here we will use the default resolution of 0.8.

*Q8:* Use `DimPlot` to color the cells by cluster on the "umap" graph. Write down how many 
clusters you got using a resolution of 0.8.

Hint: Look at the meta.data of you Seurat object. Here you can find the clustering results
which will be called something like "SCT_snn_res...".

```{r, eval=FALSE}

pbmc <- FindNeighbors(pbmc, dims = 1:30, reduction = "pca")
pbmc <- FindClusters(pbmc, resolution = 0.8)

# Write code here

```

*Q9:* Re-run the `FindClusters()` function using a resolution of 0.3 and 1.2. Use `DimPlot` 
to visualize these clusters on the "umap" graph and write down how many clusters you get.

```{r, eval=FALSE}
# Write your code / answer here
```

We have already provided a column in the meta data slot with celltype labels so you do 
not need to do the dirty work of defining clusters, identifying markers and annotating 
the clusters.

```{r}
pbmc <- SetIdent(pbmc, value = "celltype")
DimPlot(pbmc, group.by = "celltype", label = T)
```

These cluster annotation have been determined based on marker genes found in the literature.
For example, MS4A1 is expressed specifically by B-cells, PPBP on platelet cells and CD14 on 
Monocytes. 

*Q10:* Draw a new plot showing the expression of these three markers across in the UMAP embedding. 

Hint: You can use the function `FeaturePlot()` (type `?FeaturePlot? in the R console  for details) 
which is very similar to the function `DimPlot()`. Alternatively you can visualize the marker 
expression using another function called `VlnPlot()` (type ?VlnPlot in the R console for details).

```{r, eval=FALSE}

# Write your answer here
```

_____
## 7) Marker detection
_____

In the clustering section above you got a Seurat object where the cells had already been assigned 
a celltype label (annotated). But how would you go about if you needed to do this yourself?

What you typically want to know is what genes are specifically expressed in each cluster?
Seurat offers a couple of functions to explore this, but what you typically do is to run a 
differential expression (DE) test pairwise for each cluster against the background (all other cells).

Let's run `FindAllMarkers()` to get a table of differentially expressed genes:

```{r}
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)

# Select top markers
library(dplyr)
top2.markers <- group_by(pbmc.markers, cluster)
top2.markers <- top_n(x = top2.markers, n = 2, wt = avg_logFC)
top2.markers
```

In the `top2.markers` table you can find the top 2 most distinct marker genes per celltype 
based on adjusted p-value. In this table you can find some other metrics as well, e.g. avg_logFC
(short for average log-foldchange) that measures the expression in a celltype relative to its 
background or p_val_adj (short for adjusted p-value) which gives you a significance score for each gene.

*Q11:* Draw a new plot showing the expression of one marker per celltype on the UMAP embedding.

Hint: Use the function `FeaturePlot()` (type `?FeaturePlot? in the R console  for details). You can 
adjust the size of the plot window by shanges the fig.width and fig.height options below.

```{r, eval=FALSE, fig.width=10, fig.height=12}
# Write your code/answer here
```

In some cases you might find that a gene is highly expressed in multiple clusters. This
just means that the marker gene that you have chosen is not specific to only one cluster. 
It can be very time consuming to find good marker genes so it's usually a good idea to 
read up on the literature to see what markers other people have found previously. 

_______
### Other sources of variability
_______

It is worthwhile mentioning that there can exist other less evident sources of variability in the data. 
One common tecnhical source of variability is the presence of doublets or multiplets. Depending on the 
scRNA-seq method used to produce the data, you can expect to find some small percentage of doublets which 
is essentially two attached cells that have slipped through the size selection process. Doublets result 
in a mixed gene expression signal and can even produce "artifical" clusters. There are methods to identify 
and remove doublets from your dataset but we will not go through them here. 

Another important source of variability that is actually biological is cell cycle phase. As you all know, 
dividing cells go through a series of phases including the G1 phase (cell growth), the S phase (synthesis) 
and G2M (cell growth and mitosis). `Seurat` provides a function to estimate an `S.Score` and `G2M.Score`, 
using canonical markers which can be used to check if some cells are dividing in your data 

```{r}
pbmc <- CellCycleScoring(pbmc, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
FeaturePlot(pbmc, features = "S.Score")
```

As it turns out, there is a tiny cluster of cells with a high S.Score. In the UMAP
plot it looks like these cells belong to the _NK_ cluster. However, the cell cycle 
phase can sometimes be so determinant of the overall cell state so that cycling cells 
from different cell types form their own cluster. Usually, people are not interested 
in the cell cycle phase and simply remove these cells by setting a threshold.

*Q12:* Draw a plot showing the `G2M.Score` in the UMAP embedding and save it to a variable `p1`. 
Draw a second plot showing the `celltype` labels in the UMAP embedding and save it to a 
variable `p2`. Combine these plots to show them side by side.

Hint: You can use the "patchwork" system by simply adding plots together with `+` (?patchwork)

```{r, eval=FALSE, fig.width=10, fig.height=12}
# Write your code/answer here
```

_______
## Hand In Guidelines
_______
**How :** Briefly answer the questions marked with a ''Q'' in .Rmd file. There
are 12 of those. You can your answer in this .Rmd file and submit your complete
''.Rmd'' as your ''report'' for Lab2.

**Deadline**: Your report is due 23:59 December 13th 2020; if working in pairs -
each of you should hand in (identical) reports where the names of both authors
are clearly stated. For further information see the guidelines on the course
web-page.
