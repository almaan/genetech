---
title: "Lab2 - Basic data visualization and Bulk RNA-seq analysis"
author: "Sami Saarenpää"
date: "22 Sep 20"
output:
  tufte::tufte_html: default
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

# Introduction
***

For this second lab we will work with bulk RNA-seq data obtained from breast cancer samples 
downloaded from The Cancer Genome Atlas (TCGA). Each sample reprents a patient from the BRCA-TCGA
cohort and have been classified into six different "mRNA subtypes"; Her2, Basal-like, LumA, LumB, 
Normal-like and Normal. The full cohort consists of 1217 patients but for the purpose of 
this exercise, we have reduced this dataset to 10 patients per subtype, adding to a total of
60 samples.

In literature, you will most likely come across different classifications depending on
histopathology, clinical grade, receptor status and genomic alterations. Here we will 
use the "mRNA subtypes" as defined by the TCGA. 

LumA (Luminal A) : 

## Load the data

The data for the second lab is available from the cloned GitHub repo, found in genetech/labs/ex2/data/.
You will need to adjust the file paths in the code chunk below to have the correct input. Replace 
"__add path here__" with the path to genetech/labs/ex2/data/.

```{r, eval=TRUE, echo=TRUE}

counts <- as.matrix(data.frame(data.table::fread(input = "~/genetech/labs/ex2/data/TCGA_breast_cancer_subtypes.tsv.gz", 
                                       sep = "\t",
                                       header = TRUE),
                     check.names = FALSE,
                     row.names = 1))

metadata <- read.table(file = "~/genetech/labs/ex2/data/TCGA_breast_cancer_subtypes_metadata.tsv")

# Check content of matrix
counts[1:5, 1:5] # this will print the top left corner of the matrix

# Check content of metadata
head(metadata) # this will print the top 6 rows of the data.frame

# Each row of metadata contains information about the samples (columns) in our expression matrix "counts". 
# As a sanity check, we can just make sure that the column names of "counts" are identical to the row names 
# of "metadata".
all(colnames(counts) == rownames(metadata))

```

Now, you have a `matrix` object called "exprMat" with mRNA counts for our 60 samples and `data.frame` called "metadata", 
with some experimental information associated with each sample. 


# Data visualization
***

In the first part of this lab we want to give a very basic introduction to data visualization in R using ggplot2. 
Do not rush through this part as you will be asked to create your own plots later on in the second part of this lab.
We encourage you to take your time and play around with the data at hand or other datasets for that matter 
to get familiarized with the material.

## ggplot2

ggplot2 is a graphics framework which has became very popular among R users, mainly because its aesthetically pleasing nature. The syntax for ggplot2 can seem quite difficult for beginners, but can be extremely versatile once you get the hang of it. 

To start with, a plot made with ggplot2 (let's call it a "ggplot") takes a `data.frame` as input that is typically supplied to the 
function `ggplot()`. In addition, you need to specify _what column(s)_ of the `data.frame` that should be drawn in the plot and finally, 
add a "geom" to specify what _what type_ of plot that you want to draw. We can summarize these steps as follows:

  1. Initialize a ggplot object with some input data (you can think of it as a creatoing an empty canvas)
  2. Specify what columns (variables) to include in the plot
  3. Add a "geom" that defines the plot type (e.g. a bar chart or points)

Let's try this using a basic example. We want to draw a bar chart summarizing the total number of 
samples per breast cancer subtype:

```{r ggplot1, fig.width=7, fig.height=5}

ggplot(metadata, aes(subtype)) +
  geom_bar()
  
```

That was a pretty useles example since we already knew that we had 10 samples per subtype! A quicker way of
doing this would be to simply use the `table()` function:

```{r table}

table(metadata$subtype)

```


But let's go through the code for drawing the bar chart one step at the time:

`ggplot(metadata)` : initialize a new ggplot with metadata as input

`ggplot(metadata, aes(subtype))` : tell ggplot that the column `subtype` should be included in the drawing

`ggplot(metadata, aes(subtype)) +
  geom_bar()` : add a "geom" to draw a bar chart
  
  
You have probably noticed that a function called `aes()` slipped into the code. `aes()` (short for
"aesthetic mappings") is used to tell `ggplot()` how variables in the data are mapped to visual properties
of geoms. In our example above, `geom_bar()` is a "geom" that takes some group variable,
summarizes the count for each group and draws a bar chart. So by including `aes(subtype)` we told `ggplot()` 
that out group variable "subtype" should be pulled from our metadata `data.frame`.

Geoms are functions used to draw specific types of plots, for example: 
`geom_bar()` -> bar chart
`geom_point()` -> points
`geom_line()` -> lines
`geom_histogram()` -> histogram


Geoms have quite intuitive names but you will often need to search the web for a geom that suits your needs. 
The tidyverse [website](https://ggplot2.tidyverse.org/) is a great resource to start with. You should also note 
that a geom takes different variables as input, for example `geom_histogram()` requires at least a numeric vector 
to draw a histogram whereas `geom_point()` requires two vectors with x and y coordinates to draw points. It's always 
a good idea to look at examples for how to use these geoms!

Let's move on to a slightly more interesting example. We want to make histogram of the total mRNA counts for all samples:

```{r histogram, fig.width=7, fig.height=5}

# Create a new data.frame with the total counts (= column sums of counts)
gg <- data.frame(total_counts = colSums(counts))

ggplot(gg, aes(total_counts)) +
  geom_histogram(bins = 15) # Add geom for histograms (we can also adjust the number of bins here!)

```

Just like geom_bar, geom_histogram takes one variable as input but this time it needs to be a variable
with _numeric_ values. 

Q1 - Now add a new column to the gg `data.frame` with gene log10-transformed expression values for COL1A1 and draw a new histogram with these values.

```{r COL1A1_histogram, fig.width=7, fig.height=5}

# Replace ... with the correct answer
gg$COL1A1 <- log10(...)

ggplot(gg, aes(COL1A1)) +
  geom_histogram(bins = 15)

```


If we want to compare distributions for multiple groups at the same time, it could be useful to 
use a boxplot or a violin plot instead of a histogram. Let's add a group variable to our `data.frame` 
with the breast cancer subtype.

```{r boxplot, fig.width=7, fig.height=4}

# Add a new column with subtype information to our data.frame object
gg$subtype <- metadata$subtype

# Note that the boxplot geom takes two aesthetic variables in aes(subtype, total_counts); 
# one group variable and one variable (subtype) with numeric values (total_counts)
ggplot(gg, aes(subtype, total_counts)) +
  geom_boxplot()

```

Sometimes you might want to add the raw values to the plot as well and not just summarize the 
values in a boxplot. This is quite easy to do by just adding another geom in a new layer to draw points. 
Here we'll use the `geom_jitter()` geom to draw the points which will add a bit of random variation 
along the x axis so that the points don't overlap. You can try to use `geom_point()` instead to see
what happens if you draw the points without jitter.

```{r boxplot, fig.width=7, fig.height=4}

# Add a new layer with jittered points
ggplot(gg, aes(subtype, total_counts)) +
  geom_boxplot() +
  geom_jitter()

```

Let's make this plot a bit more interesting by adding some color to the boxes:

```{r boxplot_colored, fig.width=7, fig.height=4}

# Add a new aesthetic variable which defines group to color boxes by
ggplot(gg, aes(subtype, total_counts, fill = subtype)) +
  geom_boxplot() +
  geom_jitter()

```

Here we just added a new aesthetic variable (i.e. "subtype") to `aes()`, telling `ggplot()` to map a unique color to 
each subtype. This also gave us a nice legend to the right telling us what subtype each color corresponds to. 
For some geoms the color can be defined using "fill" and sometimes by "color" which depends on the shape 
of the geom. A boxplot for example, consists of a "body" which will be colored by "fill" and the outlines
will be colored by the "color" aesthetic. We can try this out our boxplots to see what happens if we add the
"color" aesthetic.

```{r r boxplot_coloredx2, fig.width=7, fig.height=4}

# Add a new aesthetic variable which defines group to color boxes by
ggplot(gg, aes(subtype, total_counts, fill = subtype, color = subtype)) +
  geom_boxplot() +
  geom_jitter()

```

Completely useless in this case, because now we can't read any statistical properties from the boxplots 
or see the raw value points that blend with the boxes.

Now let's move on to an example with two variables. We want to compare the expression of two selected genes; 
ERBB2 and GRB7, using a "scatter plot". A scatter plot uses dots to represent values for two different 
numerical variables. We'll also apply a log10 transformation to obtain a more normal-like distribution 
of values.

```{r scatter_plot, fig.width=7, fig.height=6}

gg$POTEKP<- log10(counts["POTEKP", ] + 1) # Here we add a so called "pseuocount" to avoid taking the log10 of 0 values
gg$LINC01087 <- log10(counts["LINC01087", ] + 1)

ggplot(gg, aes(POTEKP, LINC01087)) +
  geom_point()

```

These two genes appear to be highly correlated across our dataset. To highlight this we can add 
smoothed conditional means which will fit a trendline with error bars to out scatter plot:

```{r scatter_plot_smooth, fig.width=7, fig.height=6}

ggplot(gg, aes(POTEKP, LINC01087)) +
  geom_point() +
  geom_smooth(method = lm) # Set method = lm to tell geom_smooth that we expect a linear relationship

```

But what if we don't want to make this comparison across all samples, but rather for each subtype separately?
There is a very neat way of doing this using something called "facets". We could of course just color the points 
by subtype (as we have already learned how to do), but facets are often a lot easier to interpret. By adding the 
function `facet_grid()` or `facet_wrap()` we can split the entire plot into several subplots, one for each of
our cancer subtypes. Let's take a look at how to do this:

```{r facets, fig.width=9, fig.height=6}

ggplot(gg, aes(POTEKP, LINC01087)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(vars(subtype), ncol = 3) # specify what variable to split the plot by 

# NOTE: the vars function is used to tell that the input should be evaluated
# in the context of the dataset. Without this, the facet_wrap function will 
# fail to find the facettting variable in your data.frame

```

We can still see the same trend, i.e. a high correlation between the two genes, but there's substantial variation 
across the different tumor subtypes. Also, for the basal subtype there is almost no expression of either of 
these two genes which could not be concluded from the previous plot.

This far we have looked at the distribution of total counts for each sample, but now we want to look at
the distribution of counts across all genes within each sample. Essentially, what we want to do is to create 
a boxplot for each column of our counts matrix. Below we have provided code to cast the counts matrix into
something called "long format" which makes it possible to leverage into ggplot.

```{r long_format}

counts_long <- setNames(reshape2::melt(log10(counts + 1)), nm = c("gene", "sample_id", "log10_count"))
counts_long$subtype <- metadata[counts_long$sample_id, ]$subtype
head(counts_long)

```

In this long formatted `data.frame` we have a gene name, sample id, log10 mRNA count and the subtype label. 

Q2 - Now we want you to create a histogram for each sample and color samples by cancer subtype. 

Hint: `geom_boxplot()` requries a group variable and a numeric vector, then you can pass an additional 
variable to the "fill" aesthetic to add color to the boxplots.

```{r histogram_all_counts, fig.width=12, fig.height=5}

# Replace ... with your answer
ggplot(counts_long, aes(...)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

Q3 - Now make a similar plot but with facets instead of colors.

```{r histogram_all_counts_facets, fig.width=12, fig.height=5}

# Replace ... with your answer
ggplot(counts_long, aes(...)) +
  geom_boxplot() +
  facet_wrap(vars(...), scales = "free", ncol = 6) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


# Bulk RNA-seq analysis

## General workflow

This is a general pipeline for a bulk RNA-seq analysis workflow:

pre-processing (yellow):
  * Check quality of raw reads and filter out reads with poor quality
  * Align reads to a reference genome (or construct a _de novo_ genome assembly if a reference is unavailable)
  * Annotate aligned reads to gene loci
  * Filter out aligned reads with poor mapping stats and remove PCR duplicates (if applicable)

quality control and normalization (orange):
  * Check quality of gene expression vectors and remove poor quality samples
  * Normalization is needed to adjust for technical variability across samples, e.g. differences in the amount of reads 
  * Adjust for other confounding factors, e.g. gender specific expression, experimental date and age 
  
analysis (blue):
  * Differential gene expression analysis, clustering and network analysis 

![](flowchart_rnaSeq.png)

In this lab, we once again omit several steps and start with a count matrix of
transcripts, after alignment and mapping has been carried out. We will explore
different tools that can be used for quality control, differential gene
expression and clustering.

## Analysis pipeline

### Loading packages

The following packages should be loaded. Remember, if you haven't installed a
specific package, use `BiocManager::install("packageName")`. When running this,
you often get asked "Update all/some/none? [a/s/n]:" In general, it's ok to skip
updating the rest of the packages for this lab (which can otherwise take some
time).

```{r, message=FALSE, warning=FALSE, eval= TRUE, echo=TRUE}
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(viridis)
```

### Pre-processing 

We are testing several samples for differential expression of many genes
simultaneously. This adds to the multiple testing issue, reducing the power to
detect DE (differentially expressed) genes.

Therefore, we filter out genes with all zero or low counts that does not add
anything in terms of evidence for differential expression.

Perform filtering, exlude all genes that have a total count value across all
samples of $<=10$. Use the skills you learned in Lab 1.

```{r, eval= TRUE, echo=TRUE}

#Write code
counts <- counts[rowSums(counts) > 100, ]

```

### DESeq2

We will use DESeq2 for DE analysis. 

To study DE genes we *don't need* to take into an account gene length because
the tools for DE analysis are comparing the counts between sample groups for the
same gene. However, sequencing depth and RNA composition *do need* to be taken
into account.

To normalize for sequencing depth and RNA composition, DESeq2 uses
the median of ratios method. On the user-end there is only one step, but on the
back-end there are multiple steps involved, as described below.

Let's start by looking at the variability of sequencing depth across our
samples: (is normalization needed?)

Next we’ll use box plots to check the distribution of the read counts.
For convenience, we apply a log2 transformation before visual inspection of the data because the distribution is skewed towards lower values. 

```{r, eval= TRUE, echo=TRUE}
exprMat <- counts
colnames(exprMat) <- metadata$subtype
boxplot(log2(exprMat + 0.5), ylab = "log (base 2) read counts + 0.5")

```


Q1 - What is your interpretation from the plot?

```{r}
# Add an answer
```

Now, in order to use the DESeq2 workflow, we first need to create a DESeq2
object to store our data. (Similar to our SummarizedExperiment). The code to do
this is given below:


```{r, warning=FALSE, message=FALSE, eval= TRUE, echo=TRUE}

#Create the DESeqDataSet (set design = ~1, which we change later)
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata, 
                              design = ~ 1)

#Combine factors of interest into a single factor with all combinations of the original factors
dds$group <- factor(paste0(dds$subtype))
design(dds) <- ~ group

```

Now, we can use the DESeq2 function `DESeq`. This is a function that performs
several steps, including normalization. The theory behind the model is explained [here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#theory)

```{r, message=FALSE, warning=FALSE, eval= TRUE, echo=TRUE}

dds <- DESeq(dds)

```

This might take a few minutes.

If you now print the `dds` object, you will see that the structure is similar to
the SummarizedExperiment, but with some new assays and colData.

```{r, eval= TRUE, echo=TRUE}
dds
```

For each sample, we now have a sizefactor (stored in colData). We can use this
sizefactor to normalize our samples by dividing the raw count with the size
factor. This is stored in `counts(dds, normalized=T)`

Make a similar boxplot as before, but with the normalized data.

```{r, eval= TRUE, echo=TRUE}
#Write code
normMat <- counts(dds, normalized = TRUE)
colnames(normMat) <- colData(dds)$subtype
boxplot(log2(normMat + 0.5), ylab = "log (base 2) read counts + 0.5")
```


Do you spot the difference?


### Exploratory analysis

When exploring RNAseq data, you usually want to perform some kind of
transformation before visualization. Otherwise, highly expressed genes tend to
dominate the result. A common method to deal with this is to simply take the
log2 of the counts (with a pseudocount added). However, this can lead to the
opposite situation - lowly expressed genes getting too much influence on the
result.

Another frequently used method is the variance-stabilizing transformation (VST),
this is used to disentangle the mean-variance relationship seen in count data.
VST is included in the DESeq2 package.

In RNA-Seq data, genes with larger mean expression tend to have higher observed
variances across samples. Random variables for which variance differ across
certain ranges of values are called "heteroscedastic". If we VST transform
the data, the standard deviation (sd) becomes more constant along the whole dynamic
range. The following picture illustrate this:

![effect of vst transformation](lab2_vst.png)

Let's transform our data using the VST method before looking at our samples:

```{r, eval= TRUE, echo=TRUE}

# Do this by using the DESeq2 function vst(), with parameter blind=FALSE and save the results to a variable called vst.data
vst.data <- vst(dds, blind = FALSE)
```

#### Heatmap

Heatmaps can sometimes be useful to obtain an overview of pairwise relationships between many samples at the same time. Here we have 60 samples which is a decent amount of samples and it could be useful to understand if these are correlated with each other at the gene expression level.

Using our normalized counts (VST transformed), we can compute correlation scores between each pair of samples and visualize these correlationns using the code below:

(Don't freak out if the code doesn't make any sense right now, let's just focus on the heatmap)

```{r heatmap1, eval= TRUE, echo=TRUE, fig.height=12, fig.width=13}

rv <- rowVars(assay(vst.data))
select <- order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]
pca <- prcomp(t(assay(vst.data)[select, ]))
sampleDistMatrix <- cor(t(pca$x))
diag(sampleDistMatrix) <- NA
colors <- viridis::magma(50)
pheatmap(sampleDistMatrix, col = colors, border_color = NA)

```

From the heatmap we can see that samples are ordered into a hierarchical structure based on pairwise correlations. Cells (tiny squares) with a yellow color represents a pair of samples with high correlation whereas cells with a blue color represents a pair of samples with low correlation. We can see that there are at least two larger blocks of samples with higher similarity, but right now we can only guess why this is the case.

Let's add a new component to this heatmap to show some of our sample metadata using the `annotation_col` argument in `pheatmap`. What we want to do here is to add a bar on top of the heatmap to show the cancer subtype for each sample. You can check the documentation for the `annotation_col` argument by typing `?pheatmap` in the console. 

# Q2 - Replace `...` in the code chunk below with the correct answer. Based on the characteristics of the different subtypes, can you speculate why some of them are more difficult to distinguish?

```{r heatmap2, eval= TRUE, echo=TRUE, fig.height=12, fig.width=13}

# // Replace ... with the correct code
ann <- data.frame(subtype = vst.data$subtype, row.names = colnames(sampleDistMatrix))
#ann <- data.frame(...)
pheatmap(sampleDistMatrix, col = colors, annotation_col = ann)

```


### Differential expression

When we conduct DE analysis in this manner, we are comparing 2 conditions
against each other. As noted, we have several different subtypes in this data
set, each pairwise comparison is saved as separate results in our dds object. To
view what we have:

```{r, eval= TRUE, echo=TRUE}
resultsNames(dds)
```

For example, "group_Normal_vs_Basal", contains the DE result comparing Normal against Basal.

A contrast is a linear combination of estimated log2 fold changes, which can be
used to test if differences between groups are equal to zero. To extract the DE
result for a specific drug, we may use results command:

```{r, eval= TRUE, echo=TRUE}

res <- results(dds, contrast = c("group", "Her2_TP", "Normal_NT"), tidy = TRUE)
res <- res %>% 
  arrange(padj) %>%
  filter(log2FoldChange > 2, padj < 0.01)

gg <- data.frame(subtype = colData(dds)$subtype, val = dds@assays@data$counts["ERBB2", ])
ggplot(gg, aes(subtype, val)) +
  geom_boxplot()

```

Note that the log2 fold change and Wald test p-values will be for the last
variable. (See [this
link](https://www.statisticshowto.datasciencecentral.com/wald-test/) for an
explanation on the Wald test.)

NOTE: The genes with adjusted p-values of NA have less mean normalized counts
than the optimal threshold.

Now, use this method to find the top 50 upregulated and downregulated genes
(based on adjusted p-value) for each specific drug, i.e. for drug A -> compare
responders vs non-responders. Do this for all drugs and create a list of the
genes.


```{r, eval= TRUE, echo=TRUE}
#Write code
```


# Q3 - Is there any overlap between these genes across drugs? Are there some genes
# that seem to correlate with all responders regardless of drug? Is there any drug
# with a specific set of genes?
# 
# Hint: the function `intersect()` could be useful
# 
# ```{r, eval= TRUE, echo=TRUE}
# # Add answer
# ```

Q4 - Take one or two genes and look it up. Can you make any conclusion? Motivate your finding!

```{r}
# Add answer
```

