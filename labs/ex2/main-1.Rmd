---
title: "Lab2 - Bulk RNA-seq analysis and GWAS"
author: "Sami Saarenpää"
date: "22 Sep 20"
output:
  tufte::tufte_html: default
vignette: |
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```
# Bulk RNA-seq analysis

## Introduction

For this part of the lab we are exploring RNA-seq data from mice tumors which
are treated with different kinase inhibitors. Each drug (A-F) is tested on
several mice and the tumor response is recorded (i.e. did the tumor continue to
grow above a certain threshold or not). The responses are binary classified as
"responder" and "Non_responder".


## General workflow

This is a general pipeline for a bulk RNA-seq analysis workflow:

pre-processing (yellow):
  * Check quality of raw reads and filter out reads with poor quality
  * Align reads to a reference genome (or construct a _de novo_ genome assembly if a reference is unavailable)
  * Annotate aligned reads to gene loci
  * Filter out aligned reads with poor mapping stats and remove PCR duplicates (if applicable)

quality control and normalization (orange):
  * Check quality of gene expression vectors and remove poor quality samples
  * Normalization is needed to adjust for technical variability across samples, e.g. differences in the amount of reads 
  * Adjust for other confounding factors, e.g. gender specific expression, experimental date and age 
  
analysis (blue):
  * Differential gene expression analysis, clustering and network analysis 

![](flowchart_rnaSeq.png)

In this lab, we once again omit several steps and start with a count matrix of
transcripts, after alignment and mapping has been carried out. We will explore
different tools that can be used for quality control, differential gene
expression and clustering.

## Analysis pipeline

### Loading packages

The following packages should be loaded. Remember, if you haven't installed a
specific package, use `BiocManager::install("packageName")`. When running this,
you often get asked "Update all/some/none? [a/s/n]:" In general, it's ok to skip
updating the rest of the packages for this lab (which can otherwise take some
time).

```{r, message=FALSE, warning=FALSE, eval= TRUE, echo=TRUE}
library(SummarizedExperiment)
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(viridis)
```

### Load the data

The data for the second lab is available from the cloned GitHub repo, found in
genetech/labs/ex2/data/.

```{r, eval= TRUE, echo=TRUE}

counts <- as.matrix(data.frame(data.table::fread(input = "data/TCGA_breast_cancer_subtypes.tsv.gz", 
                                       sep = "\t",
                                       header = TRUE),
                     check.names = FALSE,
                     row.names = 1))

metadata <- read.table(file = "data/TCGA_breast_cancer_subtypes_metadata.tsv")

#counts <- as.matrix(read.table("data/RNAseq_mouse_ensembl_rawCounts.csv", 
#                     sep="\t", 
#                     row.names = 1,
#                     stringsAsFactors = F,
#                     header = T))

#grep <- grepl(colnames(counts), pattern="Control*")
#counts <- counts[, !grep]
#
#treatment <- sapply(strsplit(colnames(counts), "_"), "[[", 2)
#outcome <- sapply(strsplit(colnames(counts), "_"), "[[", 3)
#replicate <- sapply(strsplit(colnames(counts), "_"), "[[", 4)
#metadata <- as.data.frame(cbind(treatment, outcome, replicate))

```

Now, you have a data.frame called "metadata", with experimental information. 

### SummarizedExperiment

Create a SummarizedExpermient object with the loaded counts, call this object `se`. See
`?SummarizedExperiment` to see how to add metadata as a parameter to the
function call.

```{r, eval= TRUE, echo=TRUE}

#Write code
se <- SummarizedExperiment(assays = SimpleList(counts = counts), colData = metadata)

```

In order to extract the metadata you type e.g. `colData(se)$subtype`.
In order to extract the count data, you type `assays(se)$counts`.

### Pre-processing 

We are testing several samples for differential expression of many genes
simultaneously. This adds to the multiple testing issue, reducing the power to
detect DE (differentially expressed) genes.

Therefore, we filter out genes with all zero or low counts that does not add
anything in terms of evidence for differential expression.

Perform filtering, exlude all genes that have a total count value across all
samples of $<=10$. Use the skills you learned in Lab 1.

```{r, eval= TRUE, echo=TRUE}

#Write code
se <- se[rowSums(assays(se)$counts) > 10, ]

```

Now print your SummarizedExperiment object. 

```{r, eval= TRUE, echo=TRUE}

#Write code
se

```

### DESeq2

We will use DESeq2 for DE analysis. 

To study DE genes we *don't need* to take into an account gene length because
the tools for DE analysis are comparing the counts between sample groups for the
same gene. However, sequencing depth and RNA composition *do need* to be taken
into account.

To normalize for sequencing depth and RNA composition, DESeq2 uses
the median of ratios method. On the user-end there is only one step, but on the
back-end there are multiple steps involved, as described below.

Let's start by looking at the variability of sequencing depth across our
samples: (is normalization needed?)

Next we’ll use box plots to check the distribution of the read counts.
For convenience, we apply a log2 transformation before visual inspection of the data because the distribution is skewed towards lower values. 

```{r, eval= TRUE, echo=TRUE}

exprMat <- assays(se)$counts
colnames(exprMat) <- colData(se)$Subtype_mRNA
boxplot(log2(exprMat + 0.5), ylab = "log (base 2) read counts + 0.5")

```


Q1 - What is your interpretation from the plot?

```{r}
# Add an answer
```

Now, in order to use the DESeq2 workflow, we first need to create a DESeq2
object to store our data. (Similar to our SummarizedExperiment). The code to do
this is given below:


```{r, warning=FALSE, message=FALSE, eval= TRUE, echo=TRUE}

#Create the DESeqDataSet (set design = ~1, which we change later)
dds <- DESeqDataSetFromMatrix(countData = assays(se)$counts,
                              colData = metadata, design = ~ 1)

#Combine factors of interest into a single factor with all combinations of the original factors
dds$group <- factor(paste0(dds$Subtype_mRNA))
design(dds) <- ~ group

```

Now, we can use the DESeq2 function `DESeq`. This is a function that performs
several steps, including normalization. The theory behind the model is explained [here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#theory)

```{r, message=FALSE, warning=FALSE, eval= TRUE, echo=TRUE}

dds <- DESeq(dds)

```

This might take a few minutes.

If you now print the `dds` object, you will see that the structure is similar to
the SummarizedExperiment, but with some new assays and colData.

```{r, eval= TRUE, echo=TRUE}
dds
```

For each sample, we now have a sizefactor (stored in colData). We can use this
sizefactor to normalize our samples by dividing the raw count with the size
factor. This is stored in `counts(dds, normalized=T)`

Make a similar boxplot as before, but with the normalized data.

```{r, eval= TRUE, echo=TRUE}
#Write code
normMat <- counts(dds, normalized = TRUE)
colnames(normMat) <- colData(dds)$Subtype_mRNA
boxplot(log2(normMat + 0.5), ylab = "log (base 2) read counts + 0.5")
```


Do you spot the difference?


### Exploratory analysis

When exploring RNAseq data, you usually want to perform some kind of
transformation before visualization. Otherwise, highly expressed genes tend to
dominate the result. A common method to deal with this is to simply take the
log2 of the counts (with a pseudocount added). However, this can lead to the
opposite situation - lowly expressed genes getting too much influence on the
result.

Another frequently used method is the variance-stabilizing transformation (VST),
this is used to disentangle the mean-variance relationship seen in count data.
VST is included in the DESeq2 package.


In RNA-Seq data, genes with larger mean expression tend to have higher observed
variances across samples. Random variables for which variance differ across
certain ranges of values are called "heteroscedastic". If we VST transform
the data, the standard deviation (sd) becomes more constant along the whole dynamic
range. The following picture illustrate this:

![effect of vst transformation](lab2_vst.png)

Let's transform our data using the VST method before looking at our samples:

```{r, eval= TRUE, echo=TRUE}

# Do this by using the DESeq2 function vst(), with parameter blind=FALSE and save the results to a variable called vst.data
vst.data <- vst(dds, blind = FALSE)

```

#### Heatmap

Heatmaps can sometimes be useful to obtain an overview of pairwise relationships between many samples at the same time. Here we have 50 samples which is a decent amount of samples and it could be useful to understand if these are correlated with each other at the gene expression level.

Using our normalized counts (VST transformed), we can compute correlation scores between each pair of samples and visualize these correlationns using the code below:

(Don't freak out if the code doesn't make any sense right now, let's just focus on the heatmap)

```{r heatmap1, eval= TRUE, echo=TRUE, fig.height=9, fig.width=9}

pc <- prcomp(t(assay(vst.data)))
sampleDistMatrix <- cor(t(pc$x))
diag(sampleDistMatrix) <- NA
colors <- viridis(12)
pheatmap(sampleDistMatrix, col = colors)

```

From the heatmap we can see that samples are ordered into a hierarchical structure based on pairwise correlations. Cells (tiny squares) with a yellow color represents a pair of samples with high correlation whereas cells with a blue color represents a pair of samples with low correlation. We can see that there are at least two larger blocks of samples with higher similarity, but right now we can only guess why this is the case.

Let's add a new component to this heatmap to show some of our sample metadata using the `annotation_col` argument in `pheatmap`. What we want to do here is to add a bar on top of the heatmap to show the cancer subtype for each sample. You can check the documentation for the `annotation_col` argument by typing `?pheatmap` in the console. 

# Q2 - Replace `...` in the code chunk below with the correct answer. Based on the characteristics of the different subtypes, can you speculate why some of them are more difficult to distinguish?

```{r heatmap2, eval= TRUE, echo=TRUE, fig.height=9, fig.width=9}

# // Replace ... with the correct code
#ann <- data.frame(subtype = vst.data$Subtype_mRNA, row.names = colnames(sampleDistMatrix))
ann <- data.frame(...)
pheatmap(sampleDistMatrix, col = colors, annotation_col = ann)

```


### Differential expression

When we conduct DE analysis in this manner, we are comparing 2 conditions
against each other. As noted, we have several different subtypes in this data
set, each pairwise comparison is saved as separate results in our dds object. To
view what we have:

```{r, eval= TRUE, echo=TRUE}
resultsNames(dds)
```

For example, "group_Normal_vs_Basal", contains the DE result comparing Normal against Basal.

A contrast is a linear combination of estimated log2 fold changes, which can be
used to test if differences between groups are equal to zero. To extract the DE
result for a specific drug, we may use results command:

```{r, eval= TRUE, echo=TRUE}

res <- results(dds, contrast = c("group", "Basal", "Normal"), tidy = TRUE)

```

Note that the log2 fold change and Wald test p-values will be for the last
variable. (See [this
link](https://www.statisticshowto.datasciencecentral.com/wald-test/) for an
explanation on the Wald test.)

NOTE: The genes with adjusted p-values of NA have less mean normalized counts
than the optimal threshold.

Now, use this method to find the top 50 upregulated and downregulated genes
(based on adjusted p-value) for each specific drug, i.e. for drug A -> compare
responders vs non-responders. Do this for all drugs and create a list of the
genes.


```{r, eval= TRUE, echo=TRUE}
#Write code
```


# Q3 - Is there any overlap between these genes across drugs? Are there some genes
# that seem to correlate with all responders regardless of drug? Is there any drug
# with a specific set of genes?
# 
# Hint: the function `intersect()` could be useful
# 
# ```{r, eval= TRUE, echo=TRUE}
# # Add answer
# ```

Q4 - Take one or two genes and look it up. Can you make any conclusion? Motivate your finding!

```{r}
# Add answer
```

